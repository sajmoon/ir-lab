{{källor|månad=2010-05}}'''C''' är ett generellt, [[imperativ programmering|imperativt]] [[programspråk]]. Det tillhör familjen [[Algol (programspråk)|Algol]]-baserade språk och är avsett för [[strukturerad programmering]]. C är ett av de mest inflytelserika [[högnivåspråk]]en. [[Kompilator]]er finns för nästan alla plattformar. Det har också inspirerat många andra språk, som [[C++]] och [[Java (programspråk)|Java]].== Historia ==[[Fil:Ken n dennis.jpg|miniatyr|Ken Thompson och Dennis Ritchie.]]Under slutet av 1960-talet började [[Unix]] utvecklas ur [[Multics]] vid dåvarande [[Bell Labs]] (nuvarande [[AT&amp;T Bell Labs]]). [[Dennis Ritchie]] och [[Ken Thompson]] skrev det i [[assembler]] för [[minidator]]n [[PDP-7]]. För att kunna skriva om det i ett [[högnivåspråk]] skapade Thompson med Ritchies hjälp programspråket [[B (programspråk)|B]], en förenklad, minimalistisk version av [[BCPL]] anpassad för begränsat minnesutrymmet. BCPL är i sin tur en förenklad version av [[Combined Programming Language|CPL]]. B introducerade flera syntaktiska egenskaper som återfinns i C, såsom att jämförelser görs med dubbla [[likamedtecken]]. B började användas 1969.B var dock inte ett generellt, plattformsoberoende programspråk. Det var anpassat för den hårdvara som det var skrivet på, PDP-7, och hade bland annat bara en enda datatyp ([[ord (datorterm)|ordtypen]]). Ritchie påbörjade därför 1969 utvecklingen av ett nytt språk baserat på B, som han kallade för C, som skulle fungera på såväl [[mainframe]]datorer som [[minidator|mini]]- och [[mikrodator]]er. Den första officiella versionen av Unix kom 1970. Det var då helt skrivet i assembler för [[PDP-11]]. Det motiverade än mer utvecklingen av C. Enligt Ritchie skedde den mesta utvecklingen av språket under 1972, och 1973 var det tillräckligt avancerat för att stora delar av Unix kunde skrivas om i det.I Unix och C:s standardbibliotek anges tidsangivelser vanligen som antal sekunder sedan midnatt den 1 januari 1970, så kallad [[Unix time]].=== K&amp;R C ===1978 gav Ritchie tillsammans med [[Brian Kernighan]] ut den första utgåvan av ''[[The C Programming Language]]'', även känd som ''K&amp;R'' efter &quot;Kernighan &amp; Ritchie&quot;. Boken fungerade länge både som referensverk och som en informell specifikation av språket. De tidiga C-kompilatorerna var inte alltid så strikta med syntaxen, vilket ledde till viss frihet. Den version av C som introducerades i boken kallas för ''K&amp;R C''. Boken använde en formateringsstil, det vill säga regler för var man använder mellanslag och radbrytningar i källkoden, som lever kvar än i dag.Några av de språkegenskaper som ''K&amp;R'' introducerade var:* ett standardbibliotek för [[I/O]]* datatyperna &quot;long int&quot; och &quot;unsigned int&quot;* ett entydigt sätt att skriva kortformer av tilldelning och operation på:** kortform för tilldelningen &lt;code&gt;i=i-10&lt;/code&gt; (''i'' tilldelas värdet av ''i'' minus 10) ändrades från &lt;code&gt;i=-10&lt;/code&gt; till &lt;code&gt;i-=10&lt;/code&gt; för att undvika sammanblandning med tilldelning av negativa tal, &lt;code&gt;i=(-10)&lt;/code&gt;Den andra utgåvan av boken kom 1988. Den behandlar det standardiserade [[ANSI]] C, som är mycket striktare i syntaxen.=== ANSI och ISO C (C89/C90/C95) ==={{huvudartikel|ANSI C}}Under slutet av 1970-talet och början av 1980-talet skrevs C-kompilatorer för ett stort antal [[mainframe]]datorer, [[minidator]]er och [[mikrodator]]er. Dessa var inte alltid kompatibla med varandra. 1983 skapade [[ANSI]] en kommitté kallad X3J11 med målet att skapa en specifikation för C. Den ratificerades den 7 december 1989&lt;ref&gt;{{webbref|url=http://publications.gbdirect.co.uk/c_book/preface/standards.html|titel=Standards|verk=The C Book|utgåva=2|utgivare=GBdirect Ltd|datum=1991|hämtdatum=24 april 2011}}&lt;/ref&gt; som ANSI X3.159-1989 &quot;Programming Language C&quot;. Denna variant av C refereras oftast till som ANSI C eller C89. Året därpå antogs ANSI C som [[ISO]]-standard med namnet ISO/IEC 9899:1990. Denna version kallas ibland C90, och är i praktiken identisk med C89.Redan under arbetet med att anta ANSI C som ISO-standard lades nya förslag fram på utökningar och förbättringar. Eftersom behovet av en färdig standard var trängande togs dessa förslag inte upp för behandling. I stället behandlades de separat och samlades i ett tillägg som lades fram i september 1994 och antogs året därpå som ISO/IEC 9899:1990/Amd 1:1995. Detta tillägg kallas ''Normative Addendum 1'', ''Amendment 1'' eller ''C95''.ANSI C inkluderar många av de utökningar av språket som hade skett under årens gång. Dessutom lades några nya egenskaper till, bland annat funktionsprototyper och void-pekare. Vissa förbättringar kom från [[C++]]. I samband med detta infördes krav på att kompliatorn skulle kontrollera typerna på parametrar till funktioner. Innan C89 gjordes detta inte (externa funktioner deklararerades &lt;code&gt;int my_func();&lt;/code&gt;), något som gjorde att en del ansåg C inte vara ett högnivåspråk.Fortfarande flera år efter ratificeringen av ANSI C ansågs K&amp;R C vara den minsta gemensamma nämnare som programmerare utvecklade för för att maximera kodens kompatibilitet.=== C99 ==={{huvudartikel|C99}}1995 gjordes några ändringar i ISO-standarden, bland annat för att förbättra stödet för olika teckenuppsättningar. 1999 kom en ny specifikation, ISO/IEC 9899:1999, vanligen kallad C99. C99 introducerade bland annat inline-funktioner, nya datatyper (&lt;code&gt;long long int&lt;/code&gt; och &lt;code&gt;complex&lt;/code&gt;) och officiellt stöd för radkommentarer som börjar med &lt;code&gt;//&lt;/code&gt;, en syntaktisk funktion som fanns i BCPL och C++, och som redan stöddes av många C-kompilatorer.C99 är mestadels bakåtkompatibel med C90, men är striktare i vissa avseenden. En funktionsdeklaration som saknar returtyp antas inte längre returnera en integer.Stödet för C99 hos C-kompilatorer är ännu 2011 bristfälligt; många kompilatorer stöder stora delar, men få stöder allt. Bland de få som har fullt stöd finns [[IBM C]].&lt;ref&gt;{{webbref|url=http://www-01.ibm.com/common/ssi/cgi-bin/ssialias?infotype=an&amp;subtype=ca&amp;supplier=897&amp;appname=IBMLinkRedirect&amp;letternum=ENUS202-161|titel=IBM C for AIX, V6.0 Now Supports the C99 Standard|utgivare=IBM|datum=2 juli 2002|hämtdatum=2 september 2011}}&lt;/ref&gt;=== C1X ===2007 påbörjades arbetet med en ny standard under det informella arbetsnamnet C1X.== Arvet från C ==Att C utvecklades hand i hand med [[Unix]] gav det en mycket stark ställning inom Unix-världen, vilken det behåller än i dag. C är alltjämt mycket använt i exempelvis [[GNU]] och [[Linux]]. C blev tidigt det dominerande språket för utveckling på [[Microsoft Windows]]-plattformen, men trängdes ut av först [[C++]] (via [[programbibliotek]]et [[Microsoft Foundation Classes]]), [[Delphi (programspråk)|Delphi]] och [[Visual Basic]], och sedermera [[C-sharp|C#]].För [[inbyggda system]] har C alltjämt en mycket stark ställning och för många [[hårdvarunära]] tillämpningar och [[realtidssystem]] är C fortfarande det dominerande språket. Starkt bidragande är att C-[[kompilator]]er finns tillgängliga för de flesta plattformar. C har fördelen för hårdvarunära programmering att man har en rik flora olika heltalstyper och att man kan konvertera pekare ganska fritt.=== Relaterade språk ===C är grund för flera andra moderna programspråk. I början av 1980-talet utvecklad [[Bjarne Stroustrup]] det [[objektorientering|objektorienterade]] språket [[C++]], där konstruktioner hämtade från [[Simula 67]] adderades till C. Det är delvis, men inte fullständigt, bakåtkompatibelt med C så att vissa program går att kompilera både som C och C++. C++ har i sin tur använts som grund för språk som [[Java (programspråk)|Java]] och [[C-sharp|C#]], som dock inte är bakåtkompatibla med vare sig C eller C++.[[Objective-C]] är ett annat objektorienterat programspråk baserat på C, med influenser från [[Smalltalk]]. Det är till skillnad från C++ fullständigt bakåtkompatibelt med C, så att källkod skrivet i C kan kompileras med en Objective-C-kompilator.== Syntax och uppbyggnad ==C är [[skiftlägeskänslig]]t, det vill säga det skiljer på versaler och gemener i nyckelord och namn. Av praxis används versaler sällan utom i preprocessordirektiv och konstanter.=== Satser och block ===Varje sats i C är ett kommando som avslutas med ett [[semikolon]], &lt;code&gt;;&lt;/code&gt;. I de flesta fall kan en sats bytas ut mot ett block av kod. Block skrivs inom [[klammerparentes]]er, &lt;code&gt;{ ... }&lt;/code&gt;.Satser och block behöver inte vara på separata rader. Flera satser kan stå på samma rad, och en sats kan vara utspridd över flera rader. Whitespace, det vill säga radbrytningar, tabulatorer och mellanslag, behandlas i de flesta fall lika, och behövs bara mellan nyckelord och namn. Denna frihet ger möjligheten till olika kodformateringsstilar, varav en av de mest kända är den som Kernighan och Ritchie använde i ''The C Programming Language'', den så kallade K&amp;R-stilen.Det främsta undantaget från whitespace-friheten är preprocessordirektiven, som måste stå först på raden och avslutas med en radbrytning eller en kommentar.&lt;source lang=&quot;C&quot;&gt;/* Preprocessordirektiv måste stå först på en egen rad. */#include &lt;stdio.h&gt;/* En deklaration utspridd över flera rader. */int main(    int argc,    char **argv){    /* Flera satser på samma rad. */    int a = 4; a = a * 4; return a;}&lt;/source&gt;=== Programflöde ===C har flera sorters villkorliga satser och slingor som styr vilken kod som exekveras.==== Villkorliga satser ====Det främsta sättet att göra villkorliga satser på är med &lt;code&gt;if&lt;/code&gt;. &lt;code&gt;if&lt;/code&gt; följs av ett logiskt uttryck inom parentes, och sedan en sats eller ett block som exekveras [[om och endast om]] det logiska uttrycket är sant. Detta kan valfritt följas av &lt;code&gt;else&lt;/code&gt; och en sats eller ett block som exekveras om och endast om det logiska uttrycket är falskt.&lt;source lang=&quot;C&quot;&gt;if(a &gt; 5)    puts(&quot;a är större än 5.&quot;);else{    puts(&quot;a är inte större än 5.&quot;);    if(a &lt; 5)        puts(&quot;a är till och med mindre än 5.&quot;);}&lt;/source&gt;Som komplement till &lt;code&gt;if&lt;/code&gt; i situationer där en och samma variabel jämförs med flera värden finns &lt;code&gt;switch&lt;/code&gt;-satsen. Den tar ett uttryck inom parentes och jämför resultatet med en lista av utfall. Utfallen skrivs med &lt;code&gt;case&lt;/code&gt; före och ett kolon efter, och fungerar ungefär som radetiketter. Kodexekveringen fortsätter från respektive rad. Till skillnad från &lt;code&gt;switch&lt;/code&gt;-satser i en del andra språk stannar exekveringen inte när nästa &lt;code&gt;case&lt;/code&gt; börjar. Vill man lämna &lt;code&gt;switch&lt;/code&gt;-satsen använder man &lt;code&gt;break&lt;/code&gt; (eller, om man vill avbryta hela funktionen, &lt;code&gt;return&lt;/code&gt;). Om ingen matchande &lt;code&gt;case&lt;/code&gt; finns fortsätter exekveringen från &lt;code&gt;default&lt;/code&gt; om det finns, annars hoppas satsen över.I exemplet nedan testas variabeln &lt;code&gt;a&lt;/code&gt;. Om &lt;code&gt;a&lt;/code&gt; är lika med 1 fortsätter programmet från &lt;code&gt;case 1&lt;/code&gt;. Om &lt;code&gt;a&lt;/code&gt; är lika med 2 fortsätter programmet från &lt;code&gt;case 2&lt;/code&gt;. Eftersom &lt;code&gt;case 1&lt;/code&gt; inte avslutas med &lt;code&gt;break&lt;/code&gt; kommer exekveringen att fortsätta in i &lt;code&gt;case 2&lt;/code&gt; så att båda utskrifterna görs.&lt;source lang=&quot;C&quot;&gt;switch(a){case 1:    puts(&quot;a är lika med 1.&quot;);case 2:    puts(&quot;a är lika med 1 eller 2.&quot;);    break;case 3:case 4:case 5:    puts(&quot;a är lika med 3, 4 eller 5.&quot;);    break;default:    puts(&quot;a:s värde var inte med i listan.&quot;);}&lt;/source&gt;==== Slingor ====C har tre olika sorters slingor: &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; och &lt;code&gt;do while&lt;/code&gt;.&lt;code&gt;for&lt;/code&gt; används vanligen för att iterera genom ett antal element, till exempel en lista, med hjälp av en räknare. &lt;code&gt;for&lt;/code&gt; följs av en parentes med tre semikolonseparerade satser:# En sats eller en variabeldefinition som körs före slingan; typiskt tilldelas här en räknare sitt startvärde.# Ett villkor för om slingan upprepas eller inte.# En sats som körs sist i slingan; typiskt räknas räknaren upp här.Sedan följer ett kodblock (eller en sats) som utgör själva slingan.När en &lt;code&gt;for&lt;/code&gt;-slinga exekveras utförs först den första satsen. Om en variabel definieras i den första satsen sträcker sig dess definitionsområde endast till slingan, och kan inte användas efteråt. Sedan görs en test av villkoret; om det är falskt så avslutas slingan, annars exekveras kodblocket. När kodblocket har exekverats kommer den sista satsen från &lt;code&gt;for&lt;/code&gt;-satsen. Sedan hoppar programmet tillbaka till villkoret och fortsätter därifrån.&lt;source lang=&quot;C&quot;&gt;/* Skriver ut n och kvadraten av n för n = 1 till 25. */for(int n = 1; n &lt;= 25; n++){    printf(&quot;%d %d\n&quot;, n, n*n);}&lt;/source&gt;Alla tre delar i &lt;code&gt;for&lt;/code&gt;-satsen är valfria och kan lämnas tomma. Villkoret räknas som alltid sant om det utlämnas.&lt;code&gt;while&lt;/code&gt; är en enklare slinga än for. Den följs av en parentes med endast ett villkor.&lt;source lang=&quot;C&quot;&gt;/* Upprepa slingan så länge som getchar() inte returnerar bokstaven 'a'. */printf(&quot;Tryck på a för att fortsätta.&quot;);while(getchar() != 'a'){    printf(&quot;Fel! Tryck på a.&quot;);}printf(&quot;Rätt!&quot;);&lt;/source&gt;&lt;code&gt;do while&lt;/code&gt; fungerar precis som &lt;code&gt;while&lt;/code&gt;, förutom att villkoret inte testas före första exekveringen. &lt;code&gt;do while&lt;/code&gt;-slingan är därför garanterad att exekveras åtminstone en gång.&lt;source lang=&quot;C&quot;&gt;/* Upprepa slingan så länge som getchar() inte returnerar bokstaven 'a'. */do{    printf(&quot;Tryck på a för att fortsätta.&quot;);}while(getchar() != 'a');printf(&quot;Rätt!&quot;);&lt;/source&gt;En slinga kan avbrytas i förtid med nyckelordet &lt;code&gt;break&lt;/code&gt;. Exekveringen fortsätter då direkt efter slingan. Om programmet nästlar flera nivåer av slingor är det den närmaste som avbryts. Det går också att hoppa över resten av koden och fortsätta till nästa varv i slingan med nyckelordet &lt;code&gt;continue&lt;/code&gt;. I &lt;code&gt;for&lt;/code&gt;-slingor exekveras inkrementeringen, och i samtliga slingor testas villkoret.==== Ovillkorliga hopp ====C tillhandahåller &lt;code&gt;[[goto]]&lt;/code&gt;, men det används i praktiken mycket sparsamt. Med &lt;code&gt;goto&lt;/code&gt; kan man hoppa till en valfri plats i koden. Denna plats identifieras med ett namn, en radetikett, och avslutas med ett kolon.&lt;source lang=&quot;C&quot;&gt;int a = 5;goto hopp;a = 7; /* Den här raden exekveras aldrig. */hopp:printf(&quot;%d\n&quot;, a); /* Skriver alltid ut &quot;5&quot;. */&lt;/source&gt;Andra ovillkorliga hopp är &lt;code&gt;continue&lt;/code&gt;, som hoppar till nästa iteration av en slinga; &lt;code&gt;break&lt;/code&gt;, som hoppar ur en slinga eller &lt;code&gt;switch&lt;/code&gt;-sats; och &lt;code&gt;return&lt;/code&gt;, som hoppar ur en funktion.=== Funktioner ===En funktion definieras i C med först en returtyp, sedan namnet på funktionen, och sist en [[kommatecken|komma]]separerad lista av parametrar inom parentes. Sedan följer ett kodblock med funktionens kod. Om funktionen har en returtyp (det vill säga inte &lt;code&gt;[[#void|void]]&lt;/code&gt;) avslutas den med nyckelordet &lt;code&gt;return&lt;/code&gt; och returvärdet. &lt;code&gt;return&lt;/code&gt; måste inte ligga sist i funktionen, utan kan användas till exempel i villkorliga satser för att avsluta en funktion innan den har nått slutet.&lt;source lang=&quot;C&quot;&gt;/* En funktion som returnerar summan av två heltal. */int summa(int a, int b){    return a + b;}&lt;/source&gt;Typdeklarationen av en funktions parametrar kan utelämnas ur funktionsdeklarationen och i stället skrivas före kodblocket. Före [[C99]] var det tillåtet att helt utelämna typdeklarationen – sådana parametrar antogs då vara av typen &lt;code&gt;int&lt;/code&gt;. Dessa skrivsätt är inte vanliga eller rekommenderade.&lt;source lang=&quot;C&quot;&gt;/* En funktion som returnerar summan av två heltal. */int summa(a, b)    int a, b; /* Denna rad är inte nödvändig i C-versioner före C99. */{    return a + b;}&lt;/source&gt;Om en funktion ska anropas från ett ställe där den inte redan är definierad, till exempel tidigare i samma källkodsfil, i en annan källkodsfil eller förkompilerad i ett [[programbibliotek]], så måste den först deklareras utan sitt kodblock så att kompilatorn känner till funktionens parametrar och returtyp. Denna deklaration sker vanligen i en [[#Headerfiler|headerfil]] som kan inkluderas från alla källkodsfiler som vill använda funktionen.&lt;source lang=&quot;C&quot;&gt;int summa(int a, int b);&lt;/source&gt;En funktion som inte returnerar ett värde (ibland kallad för ''subrutin'') ges den symboliska returtypen &lt;code&gt;[[#void|void]]&lt;/code&gt;. Om funktionen inte har några parametrar lämnas parentesen antingen tom eller med &lt;code&gt;void&lt;/code&gt;.Funktionen &lt;code&gt;summa&lt;code&gt; kan anropas med parametrar och dess returvärde kan fångas upp på följande sätt:&lt;source lang=&quot;C&quot;&gt;int x = summa(8, 13);&lt;/source&gt;==== main ====Varje C-program måste innehålla en funktion som heter &lt;code&gt;main&lt;/code&gt;. Det är i &lt;code&gt;main&lt;/code&gt; som programmet startar, programmets ''entry point''. Funktionen tar två parametrar. De innehåller de argument som har skickats till programmet: &lt;code&gt;argc&lt;/code&gt; (''argument count'') är ett heltal som säger hur många argument som har skickats med, och &lt;code&gt;argv&lt;/code&gt; (''argument vector'') är en lista av strängar med argumenten. Den första strängen i listan är alltid namnet på programmet självt, vanligen inklusive sökvägen. Funktionen returnerar ett heltal som typiskt fungerar som resultat eller felmeddelande till det anropande programmet.&lt;source lang=&quot;C&quot;&gt;/* Den normala deklarationen av main. */int main(int argc, char **argc);/* I K&amp;R C utelämnas vanligen parametrarna. */int main();/* Vissa kompilatorer tillåter att main inte returnerar något. */void main(int argc, char **argc);&lt;/source&gt;=== Kommentarer ===Kommentarer är fritext som en utvecklare kan lägga till källkoden, till exempel för att beskriva vad koden gör. Kommentarer påverkar inte programmet som sådant. En vanliga användning av kommentarer är också att maskera kod så att den inte kompileras med i programmet, vanligen i [[debug]]syfte. Detta kallas ofta för ''bortkommentering'' av källkod. Kommentarer rensas bort internt av kompilatorn innan källkoden kompileras.Kommentarer inleds med &lt;code&gt;/*&lt;/code&gt; och avslutas med &lt;code&gt;*/&lt;/code&gt;. Detta kallas ibland för blockkommentarer för att skilja dem från radkommentarer, då de kan användas för att skriva kommentarer över flera rader.Många C-kompilatorer erbjuder radkommentarer. Dessa startar med &lt;code&gt;//&lt;/code&gt; och avlutas vid radbrytning. Denna typ av kommentarer fanns i [[BCPL]] men togs inte med i [[B (programspråk))|B]] och heller inte i Ritchies ursprungliga version av C eller i ANSI C. [[C++]] tog däremot upp bruket, och i och med att många kompilatorer fungerar för både C och C++ spred sig bruket till C. Radkommentarer standardiserades i C99.&lt;source lang=&quot;c&quot;&gt;/* En blockkommentar som   sträcker sig över flera   rader. */int j; // En radkommentar kan beskriva vad koden i början av raden gör.&lt;/source&gt;=== Preprocessordirektiv ===Ett preprocessordirektiv är en instruktion till kompilatorn som modifierar källkoden innan den kompileras. Preprocessordirektiv inleds i C med &lt;code&gt;#&lt;/code&gt;, som måste stå först på raden, och avslutas vid radbrytning. De vanligaste direktiven är &lt;code&gt;#include&lt;/code&gt;, som vanligen används för att hämta funktionsdefinitioner och andra definitioner, och &lt;code&gt;#define&lt;/code&gt;, som används för att skapa [[makro]]n.{| class=&quot;wikitable&quot;! Direktiv! Beskrivning|-| #define, #undef| Definierar ett makro.|-| #error| Genererar ett felmeddelande vid kompileringen.|-| #if, #else, #elif, #endif, #ifdef, #ifndef| Villkorliga block baserade på tester|-| #include| Inkluderar andra källkodsfiler, vanligen [[#Headerfiler|headerfiler]].|-| #pragma| Kompilatorspecifika direktiv.|}=== Variabler och datatyper ===C har ett antal enkla [[datatyp]]er. Storlekarna på dem är avsiktligt vagt definierade. Därför kan det vara svårt att porta källkod från ett system till ett annat, till exempel från ett 16-bitarssystem till ett 32-bitarssystem.För att definiera en variabel i C skriver man först datatypen och sedan variabelnamnet och avslutar med semikolon. Flera variabler av samma typ kan definieras på samma gång. De separeras då av kommatecken.&lt;source lang=&quot;C&quot;&gt;/* Definiera två variabler i och j av typen int. */int i, j;&lt;/source&gt;Tilldelning av variabler görs med ett [[likamedtecken]]. Jämförelser görs med dubbla likamedtecken.&lt;source lang=&quot;C&quot;&gt;/* Om i är lika med 6 så tilldelas j värdet 1. */if(i == 6)    j = 1;&lt;/source&gt;==== Heltal ====C har två grundläggande [[heltal]]sdatatyper:* &lt;code&gt;char&lt;/code&gt;, som representerar teckendata. Storleken på en &lt;code&gt;char&lt;/code&gt; är 1 [[Byte (enhet)|byte]], det vill säga den minsta adresserbara dataenheten som är minst 8 [[bit]] stor. Alla andra datatypers storlekar är multipler av &lt;code&gt;char&lt;/code&gt;.* &lt;code&gt;int&lt;/code&gt;, som vanligen är samma storlek som datorns [[ord (datorterm)|ordtyp]], typiskt 16 (garanterad minsta storlek), 32 eller 64 bitar.De två heltalstyperna kan modifieras för att vara med eller utan tecken för att tillåta både [[positiva tal|positiva]] och [[negativa tal]]:* &lt;code&gt;signed&lt;/code&gt; (med tecken)* &lt;code&gt;unsigned&lt;/code&gt; (utan tecken)&lt;code&gt;signed&lt;/code&gt; innebär att en bit avsätts för att skilja mellan negativa och positiva tal, oftast (men inte nödvändigtvis) i [[tvåkomplementsform]]. Om ingen av dessa två anges så impliceras &lt;code&gt;signed&lt;/code&gt; för &lt;code&gt;int&lt;/code&gt;-typen. För &lt;code&gt;char&lt;/code&gt; varierar implementationen mellan olika kompilatorer.Storleken på datatypen &lt;code&gt;int&lt;/code&gt; kan modifieras:* &lt;code&gt;short&lt;/code&gt; eller &lt;code&gt;short int&lt;/code&gt;, minst 16 bitar* &lt;code&gt;long&lt;/code&gt; eller &lt;code&gt;long int&lt;/code&gt;, minst 32, ofta 64 bitar* &lt;code&gt;long long&lt;/code&gt; eller &lt;code&gt;long long int&lt;/code&gt;, minst 64 bitar (sedan [[C99]])===== Logiska/booleska värden =====I C fanns ursprungligen ingen strikt [[boolesk datatyp|boolesk typ]], vars enda värden skulle vara ''sant'' och ''falskt''. I stället används heltal av typen &lt;code&gt;int&lt;/code&gt;, där värdet noll representerar ''falskt'' och ett (eller icke-noll) representerar ''sant''. Alla logiska operationer returnerar &lt;code&gt;int&lt;/code&gt;, och alla villkorliga satser tolkar ''noll'' som ''falskt'' och alla andra värden som ''sant''.&lt;source lang=&quot;C&quot;&gt;/* Det logiska uttrycket &quot;13 &lt; 6&quot; är falskt, så x får värdet 0. */int x = 13 &lt; 6;/* 7 är icke-noll. Det tolkas därför som sant och satsen exekveras alltid. */if(7){ ... }&lt;/source&gt;I [[C99]] introducerades typen &lt;code&gt;_Bool&lt;/code&gt;, med aliaset &lt;code&gt;bool&lt;/code&gt; definierad i headerfilen &lt;code&gt;bool.h&lt;/code&gt;, som en boolesk typ som kan anta värdena ''noll'' och ''ett'' för ''falskt'' respektive ''sant''. Logiska operatorer är dock fortsatt av typen &lt;code&gt;int&lt;/code&gt;.==== Flyttal ====Det finns tre [[flyttal]]styper:* &lt;code&gt;float&lt;/code&gt;* &lt;code&gt;double&lt;/code&gt;* &lt;code&gt;long double&lt;/code&gt; (sedan [[C89]], men med bra stöd först i [[C99]])Standarden specificerar inte vad det ska vara för format på flyttalen. I de flesta implementationer är &lt;code&gt;float&lt;/code&gt; och &lt;code&gt;double&lt;/code&gt; baserade på [[IEEE 754]]:s standarder för enkel (32 bitar) och dubbel (64 bitar) precision. Den största flyttalstypen, &lt;code&gt;long double&lt;/code&gt;, har sämre stöd i standardbiblioteken, och dess implementation varierar mer mellan olika plattformar, från 64 till 128 bitar. Standarden garanterar inte att det är någon skillnad alls mellan de tre typerna, bara att &lt;code&gt;double&lt;/code&gt; är minst lika stor som &lt;code&gt;float&lt;/code&gt;, och att &lt;code&gt;long double&lt;/code&gt; är minst lika stor som &lt;code&gt;double&lt;/code&gt;.I standardbiblioteken användes ursprungligen endast &lt;code&gt;double&lt;/code&gt;; &lt;code&gt;float&lt;/code&gt; behandlades som en minnessparande typ som konverteras till &lt;code&gt;double&lt;/code&gt; vid funktionsanrop. I C99 infördes varianter av standardbibliotekens funktioner för &lt;code&gt;float&lt;/code&gt; och &lt;code&gt;long double&lt;/code&gt;, till exempel [[sinus]]funktionen &lt;code&gt;double sin(double)&lt;/code&gt; med varianterna &lt;code&gt;float sinf(float)&lt;/code&gt; och &lt;code&gt;long double sinl(long double)&lt;/code&gt;.==== Komplexa tal ====I C99 definierades en utökning för variabler som är [[komplexa tal]]. Dessa definieras med nyckelordet &lt;code&gt;_Complex&lt;/code&gt; plus en flyttalstyp. Vanligen används &lt;code&gt;complex&lt;/code&gt;, som är ett alias för &lt;code&gt;_Complex&lt;/code&gt; men som bara finns tillgängligt om man inkluderar headerfilen &lt;code&gt;complex.h&lt;/code&gt;. I samma headerfil finns konstanten &lt;code&gt;I&lt;/code&gt; definierad som den [[imaginära enheten]].De vanliga flyttalstyperna räknas som [[reella tal]]. För rent [[imaginära tal]] kan man använda &lt;code&gt;_Imaginary&lt;/code&gt; på samma sätt som &lt;code&gt;_Complex&lt;/code&gt;, med ett motsvarande alias &lt;code&gt;imaginary&lt;/code&gt;.&lt;source lang=&quot;C&quot;&gt;complex double z1, z2, z3;z1 = 5 + 2*I; /* 5 + 2i */z2 = 1 - I;   /* 1 - i */z3 = z1 * z2; /* 7 - 3i */&lt;/source&gt;==== Listor och matriser ====En lista (engelska: ''array'') definieras genom att till variabelnamnet lägga [[hakparentes]]er mellan vilka man skriver listans längd. Längden kan utelämnas om man i definitionen sätter värden på listan. För att läsa eller ändra ett värde i en lista skriver man indexet inom hakparenteser efter variabelnamnet. Det första elementet i en lista har alltid index 0.&lt;source lang=&quot;C&quot;&gt;int a[5]; /* En array med 5 element. */int b[] = {12, -4, 7, 112}; /* En array med fyra element */a[4] = b[2]; /* Det sista elementet i a tilldelas värdet av det tredje i b, det vill säga talet 7. */&lt;/source&gt;Rent syntaktiskt kan listan och indexet byta plats. Detta används dock sällan i praktiken eftersom det försvårar läsbarheten.&lt;source lang=&quot;C&quot;&gt;/* x och y tilldelas samma värde: det fjärde elementet i a. */int x = a[3];int y = 3[a];&lt;/source&gt;En matris är en lista med två dimensioner, eller en lista av listor. På samma sätt kan man bygga matriser av ännu högre dimensioner.&lt;source lang=&quot;C&quot;&gt;int m[5][12]; /* En matris med 5×12 element. */int q[10][10][10][10]; /* En fyrdimensionell matris med 10×10×10×10 element. */&lt;/source&gt;Förutom vid definitionstillfället kan listor inte tilldelas i sin helhet, bara elementvis.&lt;source lang=&quot;C&quot;&gt;int a[5], b[5];a = b; /* Inte möjligt. */&lt;/source&gt;==== Pekare ====Pekare är en speciell datatyp som hänvisar till en adress i minnet där det egentliga datat finns. Pekarvariabler definieras med en datatyp och en [[asterisk]] framför pekarnamnet:&lt;source lang=&quot;C&quot;&gt;/* Definiera en variabel av typen int, och en pekare till typen int. */int i, *p;&lt;/source&gt;En pekare kan tilldelas adressen till en annan variabel av motsvarande datatyp genom att man sätter ett [[et-tecken]] framför variabln:&lt;source lang=&quot;C&quot;&gt;/* Gör så att p pekar på i. */p = &amp;i;&lt;/source&gt;För att hämta eller manipulera värdet på den minnesadress som en pekare pekar på skriver man en asterisk framför pekaren:&lt;source lang=&quot;C&quot;&gt;/* Ändra värdet som p pekar på, det vill säga värdet av i. */*p = 17;&lt;/source&gt;En pekare kallas för en ''nullpekare'' när den pekar på minnesadressen 0. Detta räknas i princip alltid som att pekare är oinitierad och inte ännu bör användas. Att försöka att läsa från eller skriva till adress 0 leder i många moderna system till [[undantagshantering|undantag]] eller att programmet kraschar.Pekare kan användas som listor. Indexet multipliceras med datatypens storlek och adderas till minnesadressen innan värdet hämtas. På samma sätt fungerar listor som pekare till det första elementet i listan. En pekare kan tilldelas värdet av en lista; de pekar då samma minne och kan användas på samma sätt.&lt;source lang=&quot;C&quot;&gt;int *p, l[10];p = l; /* p och l pekar på samma minne. */p[2] = 7; /* Tilldelar l[2] värdet 7. */&lt;/source&gt;==== Strängar ====Det finns ingen särskilt strängtyp i C, utan en sträng är detsamma som en lista av &lt;code&gt;char&lt;/code&gt;-värden. Strängar avslutas med ett [[NULL]]-tecken, alltså en &lt;code&gt;char&lt;/code&gt; med heltalsvärdet 0. När man reserverar minnesutrymme för en sträng måste man räkna med NULL-tecknet. Statiska strängar skrivs inom dubbla citattecken; NULL-tecknet är då implicit med.Det finns inget i strängen som säger hur lång den är, eller hur mycket minne som den kan använda.&lt;source lang=&quot;C&quot;&gt;char c[] = &quot;Hej!&quot;; /* En sträng – eller en array med fem element (fyra skrivtecken plus implicit NULL) */&lt;/source&gt;Eftersom strängar är listor eller pekare går de inte att jämföra som andra variabler. I stället används särskilda funktioner i C:s standardbibliotek &lt;code&gt;string.h&lt;/code&gt; för sådana jämförelser:&lt;source lang=&quot;C&quot;&gt;char a[] = &quot;Hello&quot;, b[] = &quot;World&quot;;/* Funktionen strcmp returnerar 0 om strängarna är lika. */if(strcmp(a, b) == 0)    puts(&quot;a och b är lika.&quot;);else    puts(&quot;a och b är olika.&quot;);&lt;/source&gt;==== void ====&lt;code&gt;void&lt;/code&gt; är egentligen ingen datatyp, utan en symbol för när det inte finns någon datatyp. Den används i tre sammanhang:* För att definiera att en funktion inte har en returtyp.* För att definiera att en funktion inte tar några parametrar.* För att definiera eller typkonvertera pekare som typen &lt;code&gt;void *&lt;/code&gt;, som kan peka på vilken annan typ som helst.=== Operatorer ======= Aritmetiska operatorer====Resultatet av de aritmetiska operatorerna är värdet på operationen. Till exempel är resultatet av &lt;code&gt;b = c&lt;/code&gt; lika med det nya värdet på &lt;code&gt;b&lt;/code&gt;. Det värdet kan i sin tur tilldelas en annan variabel: &lt;code&gt;a = b = c&lt;/code&gt;. Då tilldelas &lt;code&gt;b&lt;/code&gt; värdet av &lt;code&gt;c&lt;/code&gt;, och &lt;code&gt;a&lt;/code&gt; tilldelas värdet av &lt;code&gt;b = c&lt;/code&gt;, det vill säga också &lt;code&gt;c&lt;/code&gt;. Undantaget är de [[Unär operator|unära operatorerna]] för inkrementering och dekrementering, som finns i två former: ett prefix som returnerar det nya värdet och ett suffix som returnerar det gamla.{| class=&quot;wikitable&quot;! Operator! Syntax! Resultat (värde)|-| [[Tilldelning]]| &lt;code&gt;a '''=''' b&lt;/code&gt;| Värdet på &lt;code&gt;a&lt;/code&gt; efter tilldelningen. Detta kan användas för att sätta flera variabler till samma värde: &lt;code&gt;a = b = c = 7;&lt;/code&gt;|-| [[Addition]] | &lt;code&gt;a '''+''' b&lt;/code&gt;| Summan av &lt;code&gt;a&lt;/code&gt; och &lt;code&gt;b&lt;/code&gt;.|-| [[Subtraktion]]| &lt;code&gt;a '''-''' b&lt;/code&gt;| Differensen mellan &lt;code&gt;a&lt;/code&gt; och &lt;code&gt;b&lt;/code&gt;.|- | [[Unär operator|Unärt]] plus| &lt;code&gt;'''+'''a&lt;/code&gt;| Värdet på &lt;code&gt;a&lt;/code&gt;. Om &lt;code&gt;a&lt;/code&gt; är en mindre datatyp så konverteras den till &lt;code&gt;signed int&lt;/code&gt;.|-| Unärt minus (negation)| &lt;code&gt;'''-'''a&lt;/code&gt;| Värdet på &lt;code&gt;a&lt;/code&gt; med motsatt tecken. Om &lt;code&gt;a&lt;/code&gt; är en mindre datatyp så konverteras den till &lt;code&gt;signed int&lt;/code&gt;.|-| [[Multiplikation]]| &lt;code&gt;a '''*''' b&lt;/code&gt;| Produkten av &lt;code&gt;a&lt;/code&gt; och &lt;code&gt;b&lt;/code&gt;.|-| [[Division (matematik)|Division]]| &lt;code&gt;a '''/''' b&lt;/code&gt;| Kvoten av &lt;code&gt;a&lt;/code&gt; och &lt;code&gt;b&lt;/code&gt;. Vid heltalsdivision är resultatet ett heltal.|-| [[Modulo]] (rest vid division)| &lt;code&gt;a '''%''' b&lt;/code&gt;| [[Rest (matematik)|Resten]] vid heltalsdivision av &lt;code&gt;a&lt;/code&gt; med &lt;code&gt;b&lt;/code&gt;. Fungerar endast på heltal.|-| [[Inkrement]] (prefix)| &lt;code&gt;'''++'''a&lt;/code&gt;| &lt;code&gt;a&lt;/code&gt; tilldelas värdet av &lt;code&gt;a+1&lt;/code&gt;, och det nya värdet returneras.|-| Inkrement (suffix)| &lt;code&gt;a'''++'''&lt;/code&gt;| &lt;code&gt;a&lt;/code&gt; tilldelas värdet av &lt;code&gt;a+1&lt;/code&gt;, och det gamla värdet returneras.|-| [[Dekrement]] (prefix)| &lt;code&gt;'''--'''a&lt;/code&gt;| &lt;code&gt;a&lt;/code&gt; tilldelas värdet av &lt;code&gt;a-1&lt;/code&gt;, och det nya värdet returneras.|-| Dekrement (suffix)| &lt;code&gt;a'''--'''&lt;/code&gt;| &lt;code&gt;a&lt;/code&gt; tilldelas värdet av &lt;code&gt;a-1&lt;/code&gt;, och det gamla värdet returneras.|}==== Jämförelseoperatorer ====Jämförelseoperatorer används för att jämföra två variabler eller uttryck med varandra. Resultatet av en jämförelse är ett heltal av typen &lt;code&gt;int&lt;/code&gt; med värdet noll för ''falskt'' och ett för ''sant''.{| class=&quot;wikitable&quot;! Operator! Syntax|-| [[Lika med]]| &lt;code&gt;a '''==''' b&lt;/code&gt;|-| Ej lika med| &lt;code&gt;a '''!=''' b&lt;/code&gt;|- | [[Större än]]| &lt;code&gt;a '''&gt;''' b&lt;/code&gt;|-| [[Mindre än]]| &lt;code&gt;a '''&lt;''' b&lt;/code&gt;|-| Större än eller lika med| &lt;code&gt;a '''&gt;=''' b&lt;/code&gt;|-| Mindre än eller lika med| &lt;code&gt;a '''&lt;=''' b&lt;/code&gt;|}==== Logiska operatorer ====Logiska operatorer används på logiska (boolska) uttryck. Efter som C före C99 saknade en boolesk typ används heltal för att representera dessa värden: 0 betyder ''falskt'' och icke-0 ''sant''. Resultatet av de logiska operatorerna är alltid 0 för ''falskt'' och 1 för ''sant''.{| class=&quot;wikitable&quot;! Operator! Syntax|-| [[Negation (logik)|Negation]] (ICKE)| &lt;code&gt;'''!'''a&lt;/code&gt;|-| [[Konjunktion (logik)|Konjunktion]] (OCH)| &lt;code&gt;a '''&amp;amp;&amp;amp;''' b&lt;/code&gt;|-| Inklusiv [[Disjunktion (logik)|disjunktion]] (ELLER)| &lt;code&gt;a '''&lt;nowiki&gt;||&lt;/nowiki&gt;''' b&lt;/code&gt;|}==== Bitoperatorer ====Bitoperatorer används på heltal för att utföra operationer på binärrepresentationen av tal.{| class=&quot;wikitable&quot;! Operator! Syntax|-| Bitvis negation (ICKE)| &lt;code&gt;'''~'''a&lt;/code&gt;|-| Bitvis konjunktion (OCH)| &lt;code&gt;a '''&amp;''' b&lt;/code&gt;|-| Bitvis inklusiv disjunktion (ELLER)| &lt;code&gt;a '''&lt;nowiki&gt;|&lt;/nowiki&gt;''' b&lt;/code&gt;|-| Bitvis exklusiv disjunktion (XOR)| &lt;code&gt;a '''^''' b&lt;/code&gt;|-| Bitvis skiftning, vänster| &lt;code&gt;a '''&lt;&lt;''' b&lt;/code&gt;|-| Bitvis skiftning, höger| &lt;code&gt;a '''&gt;&gt;''' b&lt;/code&gt;|}==== Operatorer för sammansatt aritmetik och tilldelning ====Redan i [[B (programspråk)|B]] fanns möjligheten att utföra en operation på en variabel och tilldela variabeln resultatet med en förenklad syntax. Fördelen är tydligast när vänsterledet är ett komplicerat uttryck, till exempel en listelement med ett artimetiskt uttryck som index. Resultatet av uttrycket är detsamma som vid en vanlig tilldelning.&lt;source lang=&quot;C&quot;&gt;/* Följande uttryck är ekvivalenta */a = a * b;a *= b;&lt;/source&gt;{| class=&quot;wikitable&quot;! Operator! Syntax|-| Addition och tilldelning| &lt;code&gt;a '''+=''' b&lt;/code&gt;|-| Subtraktion och tilldelning| &lt;code&gt;a '''-=''' b&lt;/code&gt;|-| Multiplikation och tilldelning| &lt;code&gt;a '''*=''' b&lt;/code&gt;|-| Division och tilldelning| &lt;code&gt;a '''/=''' b&lt;/code&gt;|-| Modulo och tilldelning| &lt;code&gt;a '''%=''' b&lt;/code&gt;|-| Bitvis konjunktion och tilldelning| &lt;code&gt;a '''&amp;=''' b&lt;/code&gt;|-| Bitvis inklusiv disjunktion och tilldelning| &lt;code&gt;a '''&lt;nowiki&gt;|&lt;/nowiki&gt;=''' b&lt;/code&gt;|-| Bitvis exklusiv disjunktion och tilldelning| &lt;code&gt;a '''^=''' b&lt;/code&gt;|-| Bitvis vänsterskiftning och tilldelning| &lt;code&gt;a '''&lt;&lt;=''' b&lt;/code&gt;|-| Bitvis högerskiftning och tilldelning| &lt;code&gt;a '''&gt;&gt;=''' b&lt;/code&gt;|}==== Objekt-, pekar- och listoperatorer ===={| class=&quot;wikitable&quot;! Operator! Syntax! Resultat|-| Listindex| &lt;code&gt;a'''['''b''']'''&lt;/code&gt;| Element nummer ''b'' från en lista ''a'' eller elementet på minnesposition ''a'' + ''b'' * ''s'', där ''a'' är en pekare och ''s'' är storleken på datatypen som ''a'' pekar på. ''a'' och ''b'' kan byta plats i uttrycket.|-| Avreferering| &lt;code&gt;'''*'''a&lt;/code&gt;| Elementet som ''a'' pekar på; detsamma som &lt;code&gt;a[0]&lt;/code&gt;.|-| Referering| &lt;code&gt;'''&amp;amp;'''a&lt;/code&gt;| En pekare till ''a''.|-| Medlem (i objekt)| &lt;code&gt;a'''.'''b&lt;/code&gt;| Medlemmen ''b'' i ''a'', där ''a'' är ett objekt av en strukturerad typ (&lt;code&gt;struct&lt;/code&gt; eller &lt;code&gt;union&lt;/code&gt;).|-| Medlem (i pekare)| &lt;code&gt;a'''-&gt;'''b&lt;/code&gt;| Medlemmen ''b'' i ''a'', där ''a'' är en pekare till ett objekt av en strukturerad typ.|}==== Övriga operatorer ===={| class=&quot;wikitable&quot;! Operator! Syntax! Resultat|- | [[Funktionsanrop]]| &lt;code&gt;a'''('''a1, a2''')'''&lt;/code&gt;| Resultatet från funktionen ''a''.|-| Komma| &lt;code&gt;a''',''' b&lt;/code&gt;| ''b''.|-| Villkorlig beräkning| &lt;code&gt;a '''?''' b ''':''' c&lt;/code&gt;| ''b'' om a är ''sant'' (icke-noll), annars ''c''.|-| Datatypstorlek| &lt;code&gt;'''sizeof''' a&lt;/code&gt;&lt;br/&gt;&lt;code&gt;'''sizeof'''(''typ'')&lt;/code&gt;| Storleken på objektet ''a'' eller datatypen ''typ'' i byte (multipler av &lt;code&gt;char&lt;/code&gt;). Storleken är av heltalstypen &lt;code&gt;size_t&lt;/code&gt; och inkluderar det eventuella utfyllnadsutrymme som kan krävas av systemet för att kunna adressera objekten.|-| Typkonvertering| &lt;code&gt;(''typ'') a&lt;/code&gt;| Värdet av ''a'' efter typkonvertering.|}=== Reserverade nyckelord ===C är ett av de språk med lägst antal nyckelord (även kallat reserverade ord): 32 stycken i C89 och 37 i C99. Nyckelord kan inte användas som namn på variabler, funktioner eller användardefinierade typer.Namnen på de tre varibeltyper som introducerades i C99 kan krocka med användardefinierade typer och variabelnamn i källkod som skrevs för C89. Därför har de fått namn som avviker från mönstret, till exempel &lt;code&gt;_Complex&lt;/code&gt;. Genom att inkludera särskilda C99-specifika header-filer får man tillgång till makron med mer typiska namn, till exempel &lt;code&gt;complex&lt;/code&gt;.Många kompilatorer har utöver dessa nyckelord en mindre grupp egna ord för olika kompilatorspecifika funktioner. Ett vanligaste är &lt;code&gt;asm&lt;/code&gt;, som används för att skriva [[assembler]]kod direkt i C-koden.{| class=&quot;wikitable&quot;! Nyckelord! Standard! Beskrivning|-| &lt;code&gt;auto&lt;/code&gt;|| Skrivs före en variabel. Anger att kompilatorn får välja hur variabeln lagras. Jämför &lt;code&gt;register&lt;/code&gt;.|-| &lt;code&gt;_Bool&lt;/code&gt;| C99| En [[boolesk]] datatyp. Används oftast genom makrot &lt;code&gt;bool&lt;/code&gt;.|-| &lt;code&gt;break&lt;/code&gt;|| Avbryter en &lt;code&gt;do&lt;/code&gt;-, &lt;code&gt;for&lt;/code&gt;-, &lt;code&gt;switch&lt;/code&gt;- eller &lt;code&gt;while&lt;/code&gt;-sats.|-| &lt;code&gt;case&lt;/code&gt;|| Anger alternativ i &lt;code&gt;switch&lt;/code&gt;-satser.|-| &lt;code&gt;char&lt;/code&gt;|| En heltalstyp.|-| &lt;code&gt;_Complex&lt;/code&gt;| C99| En [[komplexa tal|komplex]] datatyp. Används oftast genom makrot &lt;code&gt;complex&lt;/code&gt;.|-| &lt;code&gt;const&lt;/code&gt;|| Anger att en variabels värde inte kan ändras under körning.|-| &lt;code&gt;continue&lt;/code&gt;|| Hoppar till slutet av en &lt;code&gt;do&lt;/code&gt;-, &lt;code&gt;for&lt;/code&gt;- eller &lt;code&gt;while&lt;/code&gt;-sats.|-| &lt;code&gt;default&lt;/code&gt;|| Det alternativ i en &lt;code&gt;switch&lt;/code&gt;-sats som väljs när inget av de andra alternativen valdes.|-| &lt;code&gt;do&lt;/code&gt;|| En slinga vars villkor kommer efter första blocket, så att det är garanterat att exekveras minst en gång.|-| &lt;code&gt;double&lt;/code&gt;|| En datatyp för [[flyttal]].|-| &lt;code&gt;else&lt;/code&gt;|| Startar alternativgrenen i &lt;code&gt;if&lt;/code&gt;-satser.|-| &lt;code&gt;enum&lt;/code&gt;|| Definierar [[uppräkningstyp]]er.|-| &lt;code&gt;extern&lt;/code&gt;|| Tillåter att en funktions kod eller variabels lagring finns i en annan modul är den nuvarande.|-| &lt;code&gt;float&lt;/code&gt;|| En datatyp för [[flyttal]].|-| &lt;code&gt;for&lt;/code&gt;|| En slinga som vanligen används för att stega igenom listor eller liknande.|-| &lt;code&gt;goto&lt;/code&gt;|| Sats för att flytta exekveringen till en annan del av koden (se [[goto]]).|-| &lt;code&gt;if&lt;/code&gt;|| Villkorlig sats.|-| &lt;code&gt;_Imaginary&lt;/code&gt;| C99| En [[imaginära tal|imaginär]] datatyp. Används oftast genom makrot &lt;code&gt;imaginary&lt;/code&gt;.|-| &lt;code&gt;inline&lt;/code&gt;| C99| Används för att göra koden snabbare genom att eliminera funktionsanrop för små funktioner.|-| &lt;code&gt;int&lt;/code&gt;|| En heltalstyp.|-| &lt;code&gt;long&lt;/code&gt;|| En heltalstyp (även &lt;code&gt;long long&lt;/code&gt;).|-| &lt;code&gt;register&lt;/code&gt;|| Skrivs före en variabel. Anger att kompilatorn om möjligt bör hålla denna variabel i ett [[processorregister]]. Jämför &lt;code&gt;auto&lt;/code&gt;.|-| &lt;code&gt;restrict&lt;/code&gt;| C99| Används i funktionsdeklarationer för att tillåta kompilatorn att optimera koden som hanterar pekare genom att säga att två pekare inte får peka på samma minnesadress.|-| &lt;code&gt;return&lt;/code&gt;|| Avslutar en funktion. Om funktionen returnerar ett värde så måste &lt;code&gt;return&lt;/code&gt; följas av ett sådant.|-| &lt;code&gt;short&lt;/code&gt;|| En heltalstyp.|-| &lt;code&gt;signed&lt;/code&gt;|| Säger att en heltalstyp ska tillåta negativa värden.|-| &lt;code&gt;sizeof&lt;/code&gt;|| Ger storleken i bytes av en datatyp.|-| &lt;code&gt;static&lt;/code&gt;|| Deklarerar att en lokal variabel i en funktion ska behålla sitt värde mellan anrop.|-| &lt;code&gt;struct&lt;/code&gt;|| En strukturerad datatyp.|-| &lt;code&gt;switch&lt;/code&gt;|| En sats med flera villkor och flera alternativa exekveringsvägar.|-| &lt;code&gt;typedef&lt;/code&gt;|| Typdefinitioner, ett sätt att förkorta och förtydliga namn på datatyper.|-| &lt;code&gt;union&lt;/code&gt;|| En strukturerad datatyp där flera variabler delar på samma minnesutrymme.|-| &lt;code&gt;unsigned&lt;/code&gt;|| Säger att en heltalstyp bara ska tillåta positiva värden.|-| &lt;code&gt;void&lt;/code&gt;|| Säger att en funktion inte returnerar något värde eller inte tar några parametrar, eller att en pekare kan peka på vilken datatyp som helst.|-| &lt;code&gt;volatile&lt;/code&gt;|| Skrivs före en variabel. Anger att kompilatorn inte får spara variabeln i ett register, eftersom dess värde kan ändras när som helst, till exempel av andra [[Tråd (datavetenskap)|trådar]].|-| &lt;code&gt;while&lt;/code&gt;|| En slinga vars villkor kommer först, så att villkoret garanterat har testats före första exekveringen. Används även för villkoret i &lt;code&gt;do&lt;/code&gt;-satser.|}==Programbibliotek och headerfiler==C har standardiserat ett relativt litet [[programbibliotek]] med funktioner för främst in- och utdata, sträng- och minneshantering, samt matematiska funktioner. För att komma åt dem måste de dels länkas in under kompileringen, dels göras tillgängliga genom inkludering av så kallade headerfiler. En headerfil är en källkodsfil med filändelsen &lt;code&gt;.h&lt;/code&gt;, som innehåller definitioner av program, datastrukturer, makron och variabler som är externa, det vill säga inte är deklarerade i samma källkodsfil som det program eller de funktioner som använder dem.Ett exempel är standardfunktionen &lt;code&gt;printf&lt;/code&gt; som används för att formatera utskrifter till skärmen. Den är definierad i &lt;code&gt;stdio.h&lt;/code&gt;. Själva funktionen finns vanligen i ett förkompilerat programbibliotek som länkas in under kompileringen av ett program. Ett program som vill använda &lt;code&gt;printf&lt;/code&gt; måste inkludera &lt;code&gt;stdio.h&lt;/code&gt; innan den anropar funktionen, vanligen alldeles i början av källkoden:&lt;source lang=&quot;C&quot;&gt;#include &lt;stdio.h&gt;&lt;/source&gt;Genom att bara inkludera de headerfiler som behövs och bara länka in de programbibliotek som behövs kan storleken på ett C-program hållas nere.De flesta kompilatorer tillhandahåller ett antal programbibliotek utöver de som är standard. Många av dem är mer eller mindre plattformsberoende, till exempel grafiska verktyg och bibliotek för [[trådning]], något som helt saknas i standardbiblioteken.=== Lista över headerfiler ===C89 innehåller 15 headerfiler för standardbiblioteket. I tillägg Normative Addendum 1 (NA1) tillkom tre headerfiler. I C99 utökades antalet till 24.{| class=&quot;wikitable&quot;! Headerfil! Standard! Beskrivning|-| &lt;code&gt;assert.h&lt;/code&gt;|| Innehåller makrot &lt;code&gt;assert&lt;/code&gt; som används vid [[debugging]].|-| &lt;code&gt;complex.h&lt;/code&gt;| C99| Innehåller funktioner och makron för [[komplexa tal]].|-| &lt;code&gt;ctype.h&lt;/code&gt;|| Innehåller funktioner för att klassificera och konvertera tecken.|-| &lt;code&gt;errno.h&lt;/code&gt;|| För att testa felkoder från standardbiblioteket.|-| &lt;code&gt;fenv.h&lt;/code&gt;| C99| För att kontrollera flyttalsmiljön.|-| &lt;code&gt;float.h&lt;/code&gt;|| Innehåller konstanter som definierar flyttalsmiljön.|-| &lt;code&gt;inttypes.h&lt;/code&gt;| C99| Innehåller funktioner för konvertering mellan heltalstyper.|-| &lt;code&gt;iso646.h&lt;/code&gt;| NA1| För programmering i [[ISO 646]]-teckenuppsättningar.|-| &lt;code&gt;limits.h&lt;/code&gt;|| Innehåller konstanter som definierar heltalsmiljön.|-| &lt;code&gt;locale.h&lt;/code&gt;|| Innehåller funktioner och konstanter för lokalisering; se [[locale]].|-| &lt;code&gt;math.h&lt;/code&gt;|| Innehåller matematiska funktioner och konstanter.|-| &lt;code&gt;setjmp.h&lt;/code&gt;|| Innehåller makrona &lt;code&gt;setjmp&lt;/code&gt; och &lt;code&gt;longjmp&lt;/code&gt;, som används för hopp mellan funktioner.|-| &lt;code&gt;signal.h&lt;/code&gt;|| För att hantera vissa meddelanden i miljön.|-| &lt;code&gt;stdarg.h&lt;/code&gt;|| För att hantera ett varierande antal parametrar till en funktion.|-| &lt;code&gt;stdbool.h&lt;/code&gt;| C99| För den booleska datatypen.|-| &lt;code&gt;stdint.h&lt;/code&gt;| C99| För definitioner av olika heltalstyper.|-| &lt;code&gt;stddef.h&lt;/code&gt;|| Innehåller ett antal standarddefinitioner.|-| &lt;code&gt;stdio.h&lt;/code&gt;|| Innehåller standardfunktionerna för läsning och skrivning av data.|-| &lt;code&gt;stdlib.h&lt;/code&gt;|| Innehåller ett antal standardfunktioner för bland annat minnesallokering.|-| &lt;code&gt;string.h&lt;/code&gt;|| Innehåller funktioner för stränghantering.|-| &lt;code&gt;tgmath.h&lt;/code&gt;| C99| Innehåller datatypgeneriska matematiska funiktioner.|-| &lt;code&gt;time.h&lt;/code&gt;|| För konvertering mellan tids- och datumformat.|-| &lt;code&gt;wchar.h&lt;/code&gt;| NA1| Innehåller funktioner för hantering av [[Unicode]]-tecken och -strängar.|-| &lt;code&gt;wctype.h&lt;/code&gt;| NA1| Innehåller funktioner för att klassificera och konvertera Unicode-tecken.|}== Programexempel ==&quot;[[Hello, World!]]&quot; i C:&lt;source lang=&quot;c&quot;&gt; #include &lt;stdio.h&gt;  int main(void) {     printf(&quot;Hello, world!\n&quot;);     return 0; }&lt;/source&gt;Ett program där vi kan titta på givna intervaller av multiplikation av ett givet tal i:&lt;source lang=&quot;c&quot;&gt; #include &lt;stdio.h&gt;  int main (int argc, const char * argv[]) { 	int raknare, lagsta, hogsta;  	/* 	 * raknare = En räknare för att hålla koll på vilken rad vi är på vid utskriften. 	 * lagsta = Vårt lägsta värde på i. Med detta värde på i ska utskriften starta. 	 * hogsta = Vårt högsta värde på i. Efter i = n ska utskriften sluta. 	 */ 	printf(&quot;Ange lägsta värdet på i: &quot;); 	scanf(&quot;%i&quot;, &amp;lagsta); /* Vad ska lägsta värdet på i vara? */ 	printf(&quot;Ange högsta värdet på i: &quot;); 	scanf(&quot;%i&quot;, &amp;hogsta); /* Vad ska största värdet på i vara? */ 	 	printf(&quot;\n           i          i*i        i*i*i\n&quot; 		 &quot;============ ============ ============\n&quot;); 	 	for (raknare = lagsta; raknare &lt;= hogsta; raknare++) { /* Upprepning av utskriften. */ 		printf(&quot;%12i &quot;, raknare); /* Utmatning av i^1. */ 		printf(&quot;%12i &quot;, raknare*raknare); /* Utmatning av i^2. */ 		printf(&quot;%12i\n&quot;, raknare*raknare*raknare); /* Utmatning av i^3. */ 	} 	 	return 0; /* Allt OK. Avslutar programmet. */ }&lt;/source&gt;Samma program som ovan, men där vi istället anropar funktionerna kvad() och kub() för att räkna ut i^2 och i^3:&lt;source lang=&quot;c&quot;&gt; #include &lt;stdio.h&gt;  int kvad(int x) { /* Kvadrerar det värde som funktionen matas med. */ 	return (x * x); }  int kub(int x) { /* Kuberar det värde som funktionen matas med. */ 	return (x * x * x); }  int main (int argc, const char * argv[]) { 	int raknare, lagsta, hogsta, kvadrat, kubik;  	/* 	 * raknare = En räknare för att hålla koll på vilken rad vi är på vid utskriften. 	 * lagsta = Vårt lägsta värde på i. Med detta värde på i ska utskriften starta. 	 * hogsta = Vårt högsta värde på i. Efter i = n ska utskriften sluta. 	 */ 	printf(&quot;Ange lägsta värdet på i: &quot;); 	scanf(&quot;%i&quot;, &amp;lagsta); /* Vad ska lägsta värdet på i vara? */ 	printf(&quot;Ange högsta värdet på i: &quot;); 	scanf(&quot;%i&quot;, &amp;hogsta); /* Vad ska största värdet på i vara? */ 	 	printf(&quot;\n           i          i*i        i*i*i\n&quot; 		 &quot;============ ============ ============\n&quot;); 	 	for (raknare = lagsta; raknare &lt;= hogsta; raknare++) { /* Uprepning av utskriften. */ 		printf(&quot;%12i &quot;, raknare); /* Utmatning av i^1. */ 		 		kvadrat = kvad(raknare); 		printf(&quot;%12i &quot;, kvadrat); /* Utmatning av i^2. */ 		 		kubik = kub(raknare); 		printf(&quot;%12i\n&quot;, kubik); /* Utmatning av i^3. */ 	} 	 	return 0; /* Allt OK. Avslutar programmet. */ }&lt;/source&gt;Ett program som matar ut tal (1 till 10) uttryckt i kvadrat och kubik och visar högerjusterat.&lt;source lang=&quot;c&quot;&gt;#include &lt;stdio.h&gt;int main(int argc, char *argv[]){	int i;		for(i = 1; i &lt;= 10; i++)		printf(&quot;%8d %8d %8d\n&quot;, i, i*i, i*i*i);	return 0;}&lt;/source&gt;== Se även ==* [[ANSI C]]* [[C++]]* [[Java (programspråk)|Java]]* [[Objective-C]]* [[Small-C]]* [[C-sharp]]== Referenser ==&lt;references/&gt;== Externa länkar ==* [http://www.ansi.org/ ANSI]{{wikibooks|Programmering i ANSI-C|Programmering i ANSI-C}}[[Kategori:C (programspråk)| C]][[af:C (programmeertaal)]][[als:C (Programmiersprache)]][[am:ሲ (የኮ??ዩተር ??ርገማ ቋንቋ)]][[ar:سي (لغة برمجة)]][[an:Luengache de programación C]][[ast:Llinguaxe de programación C]][[az:C (proqramlaşdırma dili)]][[bn:সি (প?রোগ?রামিং ভাষা)]][[zh-min-nan:C (thêng-sek gí-giân)]][[be:C, мова праграмаванн?]][[be-x-old:C (мова праграмаваньн?)]][[bs:C programski jezik]][[br:Areg C]][[bg:C (език за програмиране)]][[ca:Llenguatge C]][[cv:Си (компьютер чĕлхи)]][[cs:C (programovací jazyk)]][[co:C (linguagiu di prugrammazione)]][[cy:C (cyfrifiadureg)]][[da:C (programmeringssprog)]][[de:C (Programmiersprache)]][[et:C (programmeerimiskeel)]][[el:C (γλώσσα π?ογ?αμματισμο?)]][[en:C (programming language)]][[es:C (lenguaje de programación)]][[eo:C (programlingvo)]][[eu:C (programazio lengoaia)]][[fa:زبان برنامه‌نویسی سی]][[fr:C (langage)]][[ga:C (Teanga ríomhchlárúcháin)]][[gl:C (programación)]][[ko:C (프로그래? 언어)]][[hy:C (ծրագրավորման լեզու)]][[hi:सी (प?रोग?रामिंग भाषा)]][[hr:C (programski jezik)]][[id:C (bahasa pemrograman)]][[ia:C (linguage de programmation)]][[is:C (forritunarmál)]][[it:C (linguaggio)]][[he:C (שפת תכנות)]][[jv:C (basa pamrograman)]][[kn:ಸಿ (ಕ?ರಮವಿಧಿ ಭಾಷೆ)]][[ka:C (პრ?გრ?მირების ენ?)]][[ku:C (zimanê bernamekirinê)]][[lo:ພາສາຊີ]][[la:C (lingua programmandi)]][[lv:C (programmēšanas valoda)]][[lt:C (kalba)]][[hu:C (programozási nyelv)]][[mk:C (програм?ки јазик)]][[mg:Fiteny C]][[ml:സി (പ?രോഗ?രാമിങ? ഭാഷ)]][[mr:सी आज?ञावली भाषा]][[ms:C (bahasa pengaturcaraan)]][[cdo:C ngṳ̄-ngiòng]][[mn:Си х?л]][[nl:C (programmeertaal)]][[ja:C言語]][[no:C (programmeringsspråk)]][[nn:Programmeringsspråket C]][[oc:C (lengatge)]][[km:ភាសា C]][[pl:C (język programowania)]][[pt:C (linguagem de programação)]][[ro:C (limbaj de programare)]][[ru:Си (?зык программировани?)]][[sah:C (программалааhын тыла)]][[sq:C (gjuhë programimi)]][[simple:C (programming language)]][[sk:C (programovací jazyk)]][[sl:Programski jezik C]][[sr:C (програм?ки језик)]][[sh:C (programski jezik)]][[fi:C (ohjelmointikieli)]][[tl:C (wikang pamprograma)]][[ta:சி (நிரலாக?க மொழி)]][[kab:C (tameslayt)]][[tt:Си (программалау теле)]][[te:సీ]][[th:ภาษาซี]][[tr:C (programlama dili)]][[bug:C (basa maprogram)]][[uk:C (мова програмуванн?)]][[vi:C (ngôn ngữ lập trình)]][[wuu:C (程?编制个言?)]][[yi:C (פר?גר?? שפר?ך)]][[zh-yue:C程?語言]][[bat-smg:C (kalba)]][[zh:C语言]]